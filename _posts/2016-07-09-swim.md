---
layout: post
title: "Swim Cloud Evaluation"
excerpt: "Here is how your Internet of Things gets massive, fast"
tags: [IoT, cloud]
image:
# pic jessica nedved swimming 1900x500-c70.jpg
  feature: https://cloud.githubusercontent.com/assets/300046/16708828/1e020bc6-45bd-11e6-9b1d-efb4246989c2.jpg
  credit: Jessica Nedved
  creditlink: http://www.jessicanedved.com/blog/?p=29
comments: true
---
<i>{{ page.excerpt }}</i>
<hr />

{% include _toc.html %}

This tutorial aims to enable someone with minimal tech experience to critically evaluate the internals of
<a target="_blank" href="http://www.swim.it/">swim.it</a> 
cloud service using its sample code.

We try to make sense of confusing marketing hype and technical buzzwords 
by explaining them in context as we take it step-by-step,
with NOTEs and PROTIPs along the way.

We try to minimize the "mental gymastics" one has to do to understand a system
by carefully sequencing the commentary below.

We'll explain these buzzwords in context:

   * real-time 
   * bidirectional
   * low latency 
   * Streams
   * stateful
   * Asynch REST API
   * push network
   * persistent links subscription
   * multiplexes
   * Reactive
   * IoT
   * Global Actor Model
   * Peer-to-Peer messaging
   * SDK
   * iOS 
   * Androic
   * Scala
   
## Wiki plan #

   Transparency of progress is presented in the wiki at:<br />
   <a target="_blank" href="https://github.com/swimit/swim-examples/wiki">
   https://github.com/swimit/swim-examples/wiki</a>

   Sure, "anyone" can code this library (in a 24 hour hackathon), 
   but this team has done it
   but putting together all the other many aspects of a software development organization.
   See my list of [what a Developer Evangelist needes to consider](/evangelist/).

   The SWIM.it organization makes its money (has a "business model") 
   from charging for traffic on servers the company sets up in the cloud or on-premesis.


## Browser sample chat in the cloud #

Let's look at how the company's sample app works to see how it interacts with their SWIM cloud.

0. Use an internet browser (such as Google Chrome) to

   <a target="_blank" href="http://chat.swim.it/#/chat/public">
   http://chat.swim.it/#/chat/public</a>

   <amp-img width="324" height="103" alt="swim chat client screen 324x103-c67.jpg"
   layout="responsive" 
   src="https://cloud.githubusercontent.com/assets/300046/16707566/7fbdf866-4590-11e6-800b-371d8d3cb18c.jpg">
   </amp-img><br /><br />

   This communicates with a SWIM service running within the AWS EC2 public cloud infrastructure.

0. Click <strong>Sign In</strong> at the lower left.
0. Select your Google account in the pop-up window that appears.

   We're assuming that you have a Google account.

0. Click Allow.

   <amp-img width="650" height="297" alt="swim chat client logged in 650x297-c62.jpg"
   layout="responsive" 
   src="https://cloud.githubusercontent.com/assets/300046/16707596/ac65cbcc-4591-11e6-9d93-529dbcbc4de3.jpg">
   </amp-img><br /><br />

0. Click on a topic <strong>channel</strong> at the left, such as "Public".

0. Type a message such as "hello".

   Because this app is intended for use as a demo for developers,
   it has a UI feature that is usually not in production apps.

   NEXT: We'll be examining each of the client code fragments exposed by the sample app
   as we build our own client app running locally.

0. Click on each of the "{}" to expose client code for the major functions performed by almost all clients:

   * The lower-left {} (next to the exit icon)  exposes code for<br />
   <a href="#Authenticating">Authenticating users</a>.
   * The upper-left {} (next to the EDIT icon)  exposes code for<br />
   <a href="#Synchronizing">Synchronizing chat channels</a>.
   * The lower-right {} (above the Send button) exposes code for<br />
   <a href="#Streaming">Streaming chat messages</a>.
   * The upper-right {} exposes code for<br />
   <a href="#Tracking">Tracking user presence</a>.
   * The {} to the left of the Message entry box exposes code for<br />
   <a href="#Posting">Posting a chat message</a>
   <br /><br />

   We next examine each below:

<a name="Authenticating"></a>

### Authenticating users #

   <pre>
gapi.auth2.currentUser.listen(function (googleUser) {
  if (googleUser.isSignedIn()) {
    var idToken = googleUser.getAuthResponse().id_token;
    swim.authorize('', {googleIdToken: idToken});
  }
});
   </pre>

   Notice the "gapi" is for Google API, which returns the "googleUser" object from the JavaScript closure function.

   QUESTION: What about other Single-sign-on (SSO) such as
   GitHub, Facebook, Twitter, etc.

   "swim.authorize" stores the {googleIdToken: idToken}.


<a name="Synchronizing"></a>

### Synchronizing channels #

   <pre>
Client:
&nbsp;
var channels = swim.downlink()
  .node('')
  .lane('group/chats')
  .primaryKey(function (channel) { return channel.chatUri; })
  .onEvent(function (message) {
    // redraw UI with elements of channels.state array
  })
  .sortBy('name') // sort alphabetically by channel name
  .keepAlive(true) // reconnect after network failure
  .syncMap(); // keep state synchronized
&nbsp;
Server:
&nbsp;
var groupChats = new service.MapLane().register('group/chats'); // map from chat URIs to channel info
var chatInfo = new service.JoinLane().register('chat/info'); // aggregate chat/info streams
chatInfo.onJoinEvent = function (message, downlink) {
  // called when channel info updates
  var groupChat = groupChats.get(downlink.nodeUri) || {};
  recon.set(groupChat, 'userCount', message.body.userCount); // update present user count
  groupChats.set(downlink.nodeUri, groupChat);
};
chatInfo.onJoinLinked = function (response, downlink) {
  // called when channel added to group
};
chatInfo.onJoinClose = function (downlink) {
  // called when channel removed from group
  groupChats.delete(downlink.nodeUri);
};
   </pre>



<a name="Streaming"></a>

### Streaming messages #


   <pre>
Client:
&nbsp;
var chat = swim.downlink()
  <a href="#websockets">.node('ws://messenger.swim.services/chat/public')</a>
  <a href="#ServiceChat">.lane('chat/room')</a>
  .onEvent(function (message) {
    // redraw UI with elements of chat.state array
  })
  .keepAlive(true) // reconnect after network failure
  .syncList(); // keep state synchronized
&nbsp;
Server:
&nbsp;
var chatRoom = new service.ListLane().register('chat/room');
   </pre>


   The `swim.downlink()` coding is "down" because
   the list of channels is obtained from the server by the code.
   Downlinks are also called "outbound" from the server.

   <a name="websockets"></a>

   ### websockets #

   The `ws://` in `.node('ws://messenger.swim.services/chat/public')` coding
   uses the websockets protocol
   instead of HTTP:// protocol currently common on websites.

   QUESTION: `wss://` is the secure form of communication which makes use of encryption
   using public and private keys generated by a Certificate Authority (CA) trusted by the client.

   The definition of the websockets protocol by the Internet Engineerng Task Force (IETF) at
   <a target="_blank" href="https://tools.ietf.org/html/rfc6455">
   https://tools.ietf.org/html/rfc6455</a>:

   "The goal of
   this technology is to provide a mechanism for browser-based
   applications that need two-way communication with servers that does
   not rely on opening multiple HTTP connections (e.g., using
   XMLHttpRequest or <iframe>s and long polling)."

   See https://en.wikipedia.org/wiki/WebSocket

   NOTE: The WebSockets protocol is what enables a <strong>continuously open</strong>
   channel of communication between client and server,
   which removes the time ("latency") loss from having to open a channel.
   
   Nevertheless, communication is kept alive also by the `.keepAlive(true)` coding
   to reconnect after network failure and
   `.syncList()` coding to keep state (status) synchronized.

   The communication is called "asynchronous" because the client does not wait
   for a request to be returned before sending another request,
   which is "syncrhonous" behavior.

   The `.lane('chat/room')` coding specifies the "lane" running in the server named "chat/room".
   Each "lane" is also called "event source".
   
   Several clients can communicate with each named lane.


<a name="Tracking"></a>

### Tracking user presence #

   <pre>
Client:
&nbsp;
var users = swim.downlink()
  .node('')
  .lane('chat/users')
  .primaryKey(function (user) { return user.email; })
  .onEvent(function (message) {
    // redraw UI with elements of users.state array
  })
  .keepAlive(true) // reconnect after network failure
  .syncMap(); // keep state synchronized
&nbsp;
Server:
&nbsp;
var chatUsers = new service.MapLane().register('chat/users');
var chatRoom = new service.ListLane().register('chat/room');
chatRoom.onEnter = function (user) {
  chatUsers.set(user.email, {email: user.email, name: user.name});
};
chatRoom.onLeave = function (user) {
  chatUsers.delete(user.email);
};
   </pre>

   The `new` keyword in coding `new service.ListLane().register('chat/room');`
   registers a new chat/room to the list of lanes within the chatRoom object
   maintained by the server.

   The `new` keyword in coding `new service.MapLane().register('chat/users');`
   registers a new user to the map of lane users  within the chatUsers object
   maintained by the server.

   The email of the user (obtained from Google)
   is the key to information about each user on the server.



<a name="Posting"></a>

### Posting a chat message #

   <pre>
Client:
&nbsp;
var message = {
  body: 'Hello, world!'
}
swim.command('', 'chat/room', message);
&nbsp;
Server:
&nbsp;
var chatRoom = new service.ListLane().register('chat/room');
   </pre>

   The "Hello, world!" text in the sample coding
   is replaced by whatever is typed in the Message field.


## Chat client libraries #

To get a better understanding of the actual code:

0. Alt-click on the demo chat client webpage to <strong>View Page Source</strong>.
   The source downloaded is (rightly) minified of 
   white space and line breaks for smaller and thus quicker usage.

   The external libraries used by the client app are:

   * <a target="_blank" href="http://chat.swim.it/scripts/modernizr.js">modernizr.js</a> (by Paul Irish)

   * <a target="_blank" href="http://chat.swim.it/scripts/jquery/jquery.min.js">jquery.min.js</a> v2.2.1 from http://jquery.com/ - https://cdnjs.com/libraries/jquery/ or https://developers.google.com/speed/libraries/

   * <a target="_blank" href="https://apis.google.com/js/platform.js">https://apis.google.com/js/platform.js</a> for Google Sign-in - see https://developers.google.com/identity/sign-in/web/sign-in


   The libraries unique (custom) to the app:

   * <a target="_blank" href="http://chat.swim.it/styles/app.min.css">styles/app.min.css</a> 
   based on <a target="_blank" href="https://github.com/necolas/normalize.css">
   github.com/necolas/normalize.css</a> 
   for a "modern alternative to CSS resets" that
   1) correct the line height in all browsers and 2) prevent adjustments of font size after orientation changes in IE and iOS.

   * <a target="_blank" href="http://chat.swim.it/scripts/app.min.js">scripts/app.min.js</a>
   <a name="Angular"></a>

   ### Angular 1 #

   JavaScript in Angular v1 (from <a target="_blank" href="http://angularjs.org">http://angularjs.org</a>)
   generate and display HTML from this CSS tag:

   <pre>
   &LT;div ui-view="main" class="main-view">
   </pre>

   The libraries specified for download:

   * <a target="_blank" href="http://chat.swim.it/scripts/angular/angular.min.js">scripts/angular/angular.min.js</a>  v1.4.9
   * <a target="_blank" href="http://chat.swim.it/scripts/angular/angular-ui-router.min.js">scripts/angular/angular-ui-router.min.js</a> v0.2.18
   * <a target="_blank" href="http://chat.swim.it/scripts/angular/angular-animate.min.js">scripts/angular/angular-animate.min.js</a> v1.4.9 
 
   * <a target="_blank" href="http://chat.swim.it/scripts/foundation/foundation-apps.min.js">foundation-apps.min.js</a> - Angular-powered framework from <a target="_blank" href="https://github.com/zurb/foundation-apps">https://github.com/zurb/foundation-apps</a>
   (CDN versions at https://cdnjs.com/libraries/foundation)
   <br /><br />

   The SWIM team defined a library of <strong>Angular directives</strong>

   <a target="_blank" href="https://github.com/swimit/swim-angular-js">
   https://github.com/swimit/swim-angular-js</a>

   The directives swimMap, swimList, etc. are implemented in
   <a target="_blank" href="https://github.com/swimit/swimjs/blob/master/examples/chat-presence/">
   https://github.com/swimit/swimjs/blob/master/examples/chat-presence/</a>

   * <a target="_blank" href="https://github.com/swimit/swimjs/blob/master/examples/chat-presence/chat.html">
   chat.html</a> 
   
   * <a target="_blank" href="https://github.com/swimit/swimjs/blob/master/examples/chat-presence/chat.js">
   chat.js</a>
   <br /><br />
   
   There is also file <a target="_blank" href="https://github.com/swimit/swimjs/blob/master/examples/chat-presence/swim.recon">
   swim.recon</a>
   which we analyze next.

## Record Notation (recon) library #


From https://github.com/swimit/swimjs/blob/master/examples/chat-presence/swim.recon

   <pre>
@server {
  port: 5619
  store: "chat.store"
  auth: test
&nbsp;
  @route {
    prefix: "/chat/"
    service: "chat"
  }
}
&nbsp;
@service {
  name: "chat"
  main: "chat.js"
}
   </pre>


In the course of construction, SWIM developers 
created a library that has general applicability for other projects.

   require('recon-js');
   https://www.npmjs.com/package/recon-js
   Record Notation (RECON)
   RECON brings attributes into the era of object notation, and provides a simple grammar and uniform tree model for attributed text markup. RECON aims to combine the minimalism of JSON with the expressiveness of XML in a human-friendly syntax.
   https://github.com/swimit/recon-js


@event, @server, @service, are <strong>datatypes</strong>
described for humans in
https://github.com/swimit/recon-js

@ack, @auth, @deauth, @event, @link, @unlink, @sync, @command, etc.
are <strong>datatypes</strong>
described for humans in
https://github.com/swimit/swim-proto-scala

SWIM has made RECON available in several programming languages:

   * https://github.com/swimit/recon-js
   * https://github.com/swimit/recon-scala
   * https://github.com/swimit/recon-java
   * https://github.com/swimit/recon-swift

   Additionally:

   * https://github.com/swimit/recon-sublime-syntax

   ~/Library/Application Support/Sublime Text 3
   Recon.sublime-syntax

Install:

   <tt><strong>
   npm install --save recon-js
   </strong></tt>

   The response:

   <pre>
npm WARN saveError ENOENT: no such file or directory, open '/usr/local/bin/package.json'
npm WARN enoent ENOENT: no such file or directory, open '/usr/local/bin/package.json'
npm WARN bin No description
npm WARN bin No repository field.
npm WARN bin No README data
npm WARN bin No license field.
   </pre>

   Here is where I'm stuck.



## Build client locally #

   NEXT: To get a even better understanding of the client app, let's construct it on a local machine.

0. A pre-requisite is to install Node.js and NPM, the Node.js Package Manager.

0. Install the Swim client using NPM:

   As described in <a target="_blank" href="https://github.com/swimit/swim-client-js">
   https://github.com/swimit/swim-client-js</a>

   <tt><strong>
   npm install --save swim-client-js
   </strong></tt>

   The response:

   <pre>
> websocket@1.0.23 install /usr/local/bin/node_modules/websocket
> (node-gyp rebuild 2> builderror.log) || (exit 0)
&nbsp;
  CXX(target) Release/obj.target/bufferutil/src/bufferutil.o
  SOLINK_MODULE(target) Release/bufferutil.node
  CXX(target) Release/obj.target/validation/src/validation.o
  SOLINK_MODULE(target) Release/validation.node
npm WARN saveError ENOENT: no such file or directory, open '/usr/local/bin/package.json'
/usr/local/bin
‚îî‚îÄ‚î¨ swim-client-js@0.4.6 
  ‚îú‚îÄ‚îÄ recon-js@0.3.9 
  ‚îú‚îÄ‚îÄ swim-proto-js@0.4.2 
  ‚îî‚îÄ‚î¨ websocket@1.0.23 
    ‚îú‚îÄ‚î¨ debug@2.2.0 
    ‚îÇ ‚îî‚îÄ‚îÄ ms@0.7.1 
    ‚îú‚îÄ‚îÄ nan@2.3.5 
    ‚îú‚îÄ‚î¨ typedarray-to-buffer@3.1.2 
    ‚îÇ ‚îî‚îÄ‚îÄ is-typedarray@1.0.0 
    ‚îî‚îÄ‚îÄ yaeti@0.0.4 
&nbsp;
npm WARN enoent ENOENT: no such file or directory, open '/usr/local/bin/package.json'
npm WARN bin No description
npm WARN bin No repository field.
npm WARN bin No README data
npm WARN bin No license field. 
   </pre>


0. <strong>On a Mac OSX (MacOS)</strong>, 
   a pre-requisite is to [install Homebrew](/macos-homebrew/)
   explained by <a target="_blank" href="http://computers.tutsplus.com/tutorials/homebrew-demystified-os-xs-ultimate-package-manager--mac-44884">
   this tutorial</a>.

   Typically, Homebrew users issue a command on its own such as `brew install swimjs`.
   Homebrew would look into its GitHub.com repo for 
   a Ruby-language (.rb) file which specifies the "formula" on how to download and install "swimjs".
   This is because the SWIM organization has not populated Homebrew's GitHub repo with "swimjs.rb".

   If it had, "swimjs" would also be found in 
   http://brewformulas.org/ and
   http://braumeister.org/

   Nevertheless, Homebrew provides a <a target="_blank" href="http://formalfriday.club/2015/01/05/creating-your-own-homebrew-tap-and-formula.html">
   mechanism for <strong>custom taps</strong></a> which enables the .rb formula file to be housed in 
   a custom GitHub.com repository rather than in the Homebrew GitHub repository.

   An example of this is<br />
   <a target="_blank" href="https://github.com/Homebrew/homebrew-games">
   https://github.com/Homebrew/homebrew-games</a><br />
   which contains several formulae.

   The SWIM organization is using that custom tap mechanism,
   as described in <a target="_blank" href="https://github.com/swimit/swimjs">
   https://github.com/swimit/swimjs</a>.

0. Run the command (from any pwd) to position the GitHub repo holding the formula:

   <tt><strong>
   brew tap <a target="_blank" href="https://github.com/swimit/swim/tree/master/repo">swimit/swim</a>
   </strong></tt>

   PROTIP: The brew tap command above goes to the user or organization called "swimit" on GitHub.com.
   The name to the right of the / slash character ("swim") is the suffix to the
   Git repository name combining "homebrew-" plus "swim" from the command, 
   yielding the URL:

   <a target="_blank" href="https://github.com/swimit/homebrew-swim/">
   https://github.com/swimit/homebrew-swim</a>.

0. Click on the link above to see in the GitHub webpage that 
   there is a single brew formula file, 
   <a target="_blank" href="https://github.com/swimit/homebrew-swim/blob/master/swimjs.rb">
   swimjs.rb</a> repeated below:

   <pre>
   class Swimjs < Formula
     desc "Swim JavaScript Runtime"
     homepage "http://www.swim.it"
     url "https://raw.githubusercontent.com/swimit/swim/master/repo/swimjs-0.1.0-alpha3.tar.gz"
     version "0.1.0-alpha3"
     sha256 "d77880795f3ab904add10de351cefe6b45fc225a5754ef29c6ce75b7892105e0"
   &nbsp;
     depends_on :java => "1.8+"
   &nbsp;
     def install
       rm_f Dir["bin/*.bat"]
       libexec.install "bin", "lib"
       bin.install_symlink Dir["#{libexec}/bin/*"]
     end
   end
   }
   </pre>

   Note about the specification above:

   * The sha256 value was pre-calculated from where the file is stored before upload.
   The "hash" is based on every byte in the file.  
   The same calculation is repeated on the file after download. 
   If the output is the same, no transmission errors occurred.

   * <strong>Java 1.8+</strong> is a dependency because when the tar.gz file is expanded,
   all files in the lib folder are <strong>.jar</strong> (java archive) files.

   * The url to file <strong>swimjs-0.1.0-alpha3.tar.gz</strong> in the formula
   is among a list of files shown on a formatted web page at<br />
   <a target="_blank" href="https://github.com/swimit/swim/tree/master/repo">
   https://github.com/swimit/swim/tree/master/repo</a>

0. Click on the URL above to see the list of files available.

0. Press command+tab to select the Terminal shell window.

0. Obtain the "swimjs" formula from within the custom "swimit" tap repo:

   <tt><strong>
   brew install swimjs
   </strong></tt>

   The response contains the location of files installed:

   <pre>
   ==> Installing swimjs from swimit/swim
   ==> Downloading https://raw.githubusercontent.com/swimit/swim/master/repo/swimjs-0.1.0-alpha3.tar.gz
   Already downloaded: /Users/mac/Library/Caches/Homebrew/swimjs-0.1.0-alpha3.tar.gz
   üç∫  /usr/local/Cellar/swimjs/0.1.0-alpha3: 38 files, 17M, built in 0 seconds
   </pre>

0. View the "swimjs" formula among others in "/usr/local/Cellar/":

   <tt><strong>
   brew list
   </strong></tt>

   <a name="JarFiles"></a>

   ### .jar files #

0. Construct the path by specifying the version "0.1.0-alpha3" as a folder, then get a tree listing of the folder:

   <tt><strong>
   tree /usr/local/Cellar/swimjs/0.1.0-alpha3
   </strong></tt>

   The response (if you have tree installed):

   <pre>
|-- INSTALL_RECEIPT.json
|-- bin
|   `-- swimjs -> ../libexec/bin/swimjs
`-- libexec
    |-- bin
    |   `-- swimjs
    `-- lib
        |-- com.fasterxml.jackson.core.jackson-core-2.1.3.jar
        |-- com.google.api-client.google-api-client-1.19.1.jar
        |-- com.google.code.findbugs.jsr305-1.3.9.jar
        |-- com.google.guava.guava-jdk5-13.0.jar
        |-- com.google.http-client.google-http-client-1.19.0.jar
        |-- com.google.http-client.google-http-client-jackson2-1.19.0.jar
        |-- com.google.oauth-client.google-oauth-client-1.19.0.jar
        |-- com.h2database.h2-mvstore-1.4.191.jar
        |-- commons-codec.commons-codec-1.3.jar
        |-- commons-logging.commons-logging-1.1.1.jar
        |-- it.reify.basis-core_2.11-0.2.1.jar
        |-- it.reify.basis-data_2.11-0.2.1.jar
        |-- it.reify.basis-net_2.11-0.2.1.jar
        |-- it.reify.basis-util_2.11-0.2.1.jar
        |-- it.swim.dive-http-scala_2.11-0.1.0-SNAPSHOT.jar
        |-- it.swim.dive-httpsocket-scala_2.11-0.1.0-SNAPSHOT.jar
        |-- it.swim.dive-io-scala_2.11-0.1.0-SNAPSHOT.jar
        |-- it.swim.dive-task-scala_2.11-0.1.0-SNAPSHOT.jar
        |-- it.swim.dive-websocket-scala_2.11-0.1.0-SNAPSHOT.jar
        |-- it.swim.recon-scala_2.11-0.2.0.jar
        |-- it.swim.swim-auth-google-scala_2.11-0.3.2-SNAPSHOT.jar
        |-- it.swim.swim-core-scala_2.11-0.3.2-SNAPSHOT.jar
        |-- it.swim.swim-meta-scala_2.11-0.3.2-SNAPSHOT.jar
        |-- it.swim.swim-network-scala_2.11-0.3.2-SNAPSHOT.jar
        |-- it.swim.swim-proto-scala_2.11-0.3.1.jar
        |-- it.swim.swim-socket-scala_2.11-0.3.2-SNAPSHOT.jar
        |-- it.swim.swim-store-scala_2.11-0.3.2-SNAPSHOT.jar
        |-- it.swim.swim-util-scala_2.11-0.3.2-SNAPSHOT.jar
        |-- it.swim.swimjs-0.1.0-SNAPSHOT.jar
        |-- joda-time.joda-time-2.7.jar
        |-- org.apache.httpcomponents.httpclient-4.0.1.jar
        |-- org.apache.httpcomponents.httpcore-4.0.1.jar
        |-- org.joda.joda-convert-1.7.jar
        |-- org.scala-lang.scala-library-2.11.7.jar
        `-- org.scala-lang.scala-reflect-2.11.7.jar
&nbsp;
4 directories, 38 files
   </pre>


.jar files reveal the technologies used:

   * Joda time from http://www.joda.org/joda-time/  a quality replacement for the Java date and time classes.
   * Jackson XML processor from http://wiki.fasterxml.com/JacksonHome
   * Guava Java utility library from https://github.com/google/guava
   * Apache commons-logging for Java from https://commons.apache.org/proper/commons-logging/

   * Scala language
   * Reify.it - A foundation library for Scala focussed on efficiency and clean design

   * h2 SQL database engine from http://www.h2database.com/

All these are rather standard for new development in 2016. 

Questions:

   * JUnit ?

   * NO SQL and caching such as Redis ?

   * Performance testing benchmark results?


### Run swimjs #

0. Run in a Terminal shell window:

   <tt><strong>
   swimjs
   </strong></tt>

   The response:

   <pre>
   Loading config from /usr/local/bin/swim.recon
   Exception in thread "main" java.nio.file.NoSuchFileException: /usr/local/bin/swim.recon
	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:86)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:102)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:107)
	at sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:214)
	at java.nio.file.Files.newByteChannel(Files.java:361)
	at java.nio.file.Files.newByteChannel(Files.java:407)
	at java.nio.file.Files.readAllBytes(Files.java:3152)
	at swim.js.JavaScriptApp$.main(JavaScriptApp.scala:43)
	at swim.js.JavaScriptApp.main(JavaScriptApp.scala)
   </pre>

   Here is where I got stuck.



## iOS App #

https://github.com/swimit/swim-todo-ios

The app makes use of Apple's Swift programming language 

https://github.com/swimit/swim-swift

Built by 
	<a target="_blank" href="https://www.ewanmellor.org/">
	San Francisco based freelance iOS developer</a>
Ewan Mellor
	(<a target="_blank" href="https://github.com/ewanmellor?tab=repositories">
	ewanmellor on GitHub</a>)


## Server run-time #

https://github.com/swimit/swimjs


https://github.com/swimit/swimjs/blob/master/API.md
contains the details



## Create To Do List client #

To-Do application

https://github.com/swimit/swim-todo-services



## Java #

https://github.com/swimit/swim-util-java

   * https://github.com/swimit/recon-java


## Rock stars #

By @c9r, Chris Sachs, chris@swim.it
https://github.com/c9r
https://www.linkedin.com/in/cdsachs
has built a Scala system before


## Companies #

DownlinkBuilder: an object used to constructor outbound links.

    URL ???


## Services #

Messaging

Fine grain control over privacy data

Intra-service and Inter-service introspection 


## Scalability #

Swim distributes the execution of Swim services across one or more clusters.


   because logic for the sample client app should be 
   built alongside the server app to ensure version integrity.
